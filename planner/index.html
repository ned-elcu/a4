<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>SOLIS Planner</title>
  <link rel="icon" href="https://regnumsolis.com/planner/images/icon.png" type="image/png" />
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" />
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: transparent;
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      overflow: hidden;
      position: relative;
    }
    /* Global marker text hover */
    .text-hover-only .marker text,
    .text-hover-only .marker rect {
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .text-hover-only .marker:hover text,
    .text-hover-only .marker:hover rect { opacity: 1; }
    /* Background container */
    #background-container {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
    }
    #waveCanvas { display: block; width: 100%; height: 100%; }
    /* Loading overlay */
    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 100;
      display: none; align-items: center; justify-content: center; flex-direction: column; font-size: 2em;
    }
    #loading-overlay img { width: 80px; height: 80px; margin-bottom: 20px; }
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes neonGlow {
      0% { text-shadow: 0 0 5px rgba(223,197,136,0.6), 0 0 10px rgba(223,197,136,0.6), 0 0 15px rgba(223,197,136,0.6); }
      100% { text-shadow: 0 0 20px rgba(223,197,136,1), 0 0 30px rgba(223,197,136,1), 0 0 40px rgba(223,197,136,1); }
    }
    @keyframes whiteNeonGlow {
      0% { text-shadow: 0 0 2px rgba(255,255,255,0.24), 0 0 4px rgba(255,255,255,0.24), 0 0 6px rgba(255,255,255,0.24); }
      100% { text-shadow: 0 0 8px rgba(255,255,255,0.4), 0 0 12px rgba(255,255,255,0.4), 0 0 16px rgba(255,255,255,0.4); }
    }
    @keyframes reducedNeonGlow {
      0% { text-shadow: 0 0 2px rgba(223,197,136,0.24), 0 0 4px rgba(223,197,136,0.24), 0 0 6px rgba(223,197,136,0.24); }
      100% { text-shadow: 0 0 8px rgba(223,197,136,0.4), 0 0 12px rgba(223,197,136,0.4), 0 0 16px rgba(223,197,136,0.4); }
    }
    @keyframes swing { 0% { transform: rotate(-10deg); } 50% { transform: rotate(10deg); } 100% { transform: rotate(-10deg); } }
    .drag-clone { animation: swing 1s ease-in-out infinite; opacity: 0.9; }
    /* Color Picker Modal */
    #color-picker-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.95);
      border: 1px solid rgba(223,197,136,0.8);
      border-radius: 8px;
      padding: 20px;
      z-index: 3000;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    #color-picker-modal h3 {
      text-align: center;
      margin-bottom: 10px;
      font-family: Arial, sans-serif;
    }
    #color-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 5px;
    }
    .color-cell {
      width: 30px;
      height: 30px;
      border: 1px solid #1e1e1e;
      cursor: pointer;
      border-radius: 4px;
    }
    .color-cell:hover {
      transform: scale(1.2);
      border: 1px solid white;
      z-index: 10;
    }
    /* Modal close button */
    #color-picker-close {
      margin-top: 10px;
      display: block;
      width: 100%;
      padding: 8px;
      background: rgba(223,197,136,0.8);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: Arial, sans-serif;
    }
    /* Login screen */
    #login-screen {
      display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
      background: rgba(30,30,30,0.9); animation: fadeIn 1s ease-out; text-align: center; position: relative; z-index: 1;
    }
    #login-screen h2 { font-size: 3em; margin-bottom: 20px; animation: neonGlow 1.5s infinite alternate ease-in-out; }
    #login-screen input {
      margin: 5px; padding: 10px; font-size: 1.2em; width: 250px; border: none; border-radius: 4px; text-align: center;
    }
    #login-screen button {
      margin-top: 10px; padding: 10px 20px; font-size: 1.2em; border: none; border-radius: 4px;
      background: rgba(223,197,136,0.8); color: white; cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s; box-shadow: 0 4px 15px rgba(223,197,136,0.5);
    }
    #login-screen button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    #login-error { margin-top: 10px; color: #e74c3c; font-weight: bold; }
    /* Main app container */
    #app { display: none; height: 100vh; position: relative; animation: fadeIn 1s ease-out; z-index: 1; }
    /* Header */
    #header-logo { text-align: center; padding: 10px 0; background: transparent; }
    #header-logo h1 {
      font-size: 1.05em;
      margin: 0;
      color: white;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
    }
    /* Right menus */
    #right-menus { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 20px; z-index: 20; }
    .menu-container {
      width: 180px; background: rgba(30,30,30,0.9); padding: 10px; border: 1px solid rgba(223,197,136,0.5);
      border-radius: 5px; box-shadow: 0 0 10px rgba(223,197,136,0.5); position: relative; transition: transform 0.3s ease;
    }
    /* Fixed menu transformation - this is critical for the menu toggle */
    .menu-container.hidden { transform: translateX(109%); }
    .menu-header { display: flex; align-items: center; justify-content: center; font-size: 1.2em; margin-bottom: 5px; position: relative; }
    .menu-toggle {
      position: absolute; left: -45px; top: -40%; background: none; border: none; font-size: 1.05em;
      color: rgb(223,197,136); cursor: pointer; padding: 0; line-height: 1; width: 22px !important; height: 23px !important; z-index: 100; pointer-events: auto;
    }
    .menu-content { display: flex; flex-direction: column; gap: 5px; }
    .menu-content button {
      width: 100%; height: 40px; border: none; border-radius: 4px; background: rgba(223,197,136,0.8);
      color: white; cursor: pointer; transition: transform 0.3s, box-shadow 0.3s; box-shadow: 0 4px 15px rgba(223,197,136,0.5);
    }
    .menu-content button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    #settings-container h2 { font-size: 1em; margin-bottom: 5px; }
    .toggle-switch {
      appearance: none; -webkit-appearance: none; width: 40px; height: 20px; background: #ccc; border-radius: 20px;
      position: relative; outline: none; cursor: pointer; transition: background 0.3s;
    }
    .toggle-switch:checked { background: #dfc588; }
    .toggle-switch::before {
      content: ""; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%;
      transition: transform 0.3s;
    }
    .toggle-switch:checked::before { transform: translateX(20px); }
    #toggle-container { display: flex; align-items: center; justify-content: center; }
    #toggle-marker-text-label { margin-left: 10px; line-height: 20px; }
    /* Override switch label fonts to use normal sans-serif */
    #settings-container .menu-content label {
      font-family: Arial, sans-serif;
    }
    /* Update the marker visibility toggles to use "keep" instead of "citadel" */
    #marker-visibility-container { margin-top: 10px; text-align: left; width: 100%; }
    #marker-visibility-container h3 { font-size: 0.9em; margin-bottom: 5px; text-align: center; }
    .toggle-item { display: flex; justify-content: space-between; align-items: center; margin: 3px 0; }
    .toggle-item label { font-size: 0.85em; flex-grow: 1; margin-left: 5px; }
    /* Toolbox */
    #toolbox {
      position: fixed; 
      top: 20px; 
      left: 20px; 
      background: rgba(30,30,30,0.9); 
      padding: 10px;
      border: 1px solid rgba(223,197,136,0.5); 
      border-radius: 5px; 
      box-shadow: 0 0 10px rgba(223,197,136,0.5); 
      z-index: 20;
      display: flex; 
      flex-direction: column; 
      gap: 10px;
    }
    /* Individual tool tooltip styling */
    .tool {
      position: relative;
      width: 50px; 
      height: 50px; 
      border: 1px solid rgba(223,197,136,0.5); 
      background: rgba(30,30,30,0.9);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      cursor: pointer; 
      border-radius: 5px; 
      transition: transform 0.3s, border-color 0.3s;
    }
    .tool:hover { transform: scale(1.1); }
    .tool img { max-width: 100%; max-height: 100%; }
    .tool::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 50%;
      left: 105%;
      transform: translateY(-50%);
      white-space: nowrap;
      background: transparent;
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1em;
      opacity: 0;
      pointer-events: none;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
      transition: opacity 0.3s ease;
      z-index: 30; /* Ensure tooltip is above other elements */
    }
    .tool:hover::after {
      opacity: 1;
    }
    /* History controls */
    #history-controls {
      position: fixed;
      top: 220px;
      left: 20px;
      display: flex;
      gap: 10px;
      z-index: 25;
    }
    #history-controls button {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 4px;
      background: rgba(30,30,30,0.9);
      border: 1px solid rgba(223,197,136,0.5);
      color: rgba(223,197,136,0.8);
      font-size: 1.2em;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    #history-controls button:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(223,197,136,0.5);
    }
    #history-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    /* Search function styling */
    #search-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      display: flex;
      z-index: 25;
    }
    #search-input {
      flex-grow: 1;
      padding: 8px 12px;
      border: 1px solid rgba(223,197,136,0.5);
      border-right: none;
      border-radius: 4px 0 0 4px;
      background: rgba(30,30,30,0.9);
      color: white;
    }
    #search-button {
      padding: 8px 12px;
      border: 1px solid rgba(223,197,136,0.5);
      border-radius: 0 4px 4px 0;
      background: rgba(223,197,136,0.8);
      color: #1e1e1e;
      cursor: pointer;
    }
    #search-results {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(30,30,30,0.95);
      border: 1px solid rgba(223,197,136,0.5);
      border-top: none;
      border-radius: 0 0 4px 4px;
      display: none;
    }
    .search-result {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(223,197,136,0.3);
    }
    .search-result:last-child {
      border-bottom: none;
    }
    .search-result:hover {
      background: rgba(223,197,136,0.3);
    }
    /* Map container */
    #map-container { width: 100vw; height: calc(100vh - 60px); overflow: hidden; }
    #map-svg-container { width: 100%; height: 100%; }
    .marker:hover { opacity: 0.8; cursor: pointer; }
    /* Error overlay */
    #error-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(30,30,30,0.95);
      color: #ecf0f1; display: none; align-items: center; justify-content: center; z-index: 50; font-size: 1.5em; text-align: center; padding: 20px;
    }
    /* Admin Panel */
    #admin-panel {
      position: fixed; bottom: 20px; left: 20px; width: 320px; background: rgba(30,30,30,0.9);
      border: 1px solid rgba(223,197,136,0.5); border-radius: 5px; box-shadow: 0 0 10px rgba(223,197,136,0.5);
      z-index: 30; display: none; animation: fadeIn 1s ease-out;
    }
    #admin-panel header {
      display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid rgba(223,197,136,0.5);
      background: rgba(30,30,30,0.95);
    }
    #admin-panel header h3 { margin: 0; font-size: 1.8em; }
    #admin-panel header .admin-controls button {
      background: none; border: none; font-size: 1.2em; color: rgb(223,197,136); cursor: pointer; margin-left: 5px;
    }
    #audit-log-container { max-height: 200px; overflow-y: auto; padding: 10px; font-size: 1.2em; }
    #audit-log-container div { margin-bottom: 5px; }
    .log-user { color: #dfc588; font-weight: bold; }
    .log-action { color: #8ac6d1; }
    .log-group { color: #dfc588; }
    #admin-panel footer {
      display: flex; justify-content: space-around; padding: 10px; border-top: 1px solid rgba(223,197,136,0.5);
      background: rgba(30,30,30,0.95);
    }
    #admin-panel footer button {
      padding: 8px 12px; font-size: 1em; border: none; border-radius: 4px; background: rgba(223,197,136,0.8);
      color: white; cursor: pointer; transition: transform 0.3s, box-shadow 0.3s;
    }
    #admin-panel footer button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    /* Footer styles */
    #footer-info {
      position: fixed;
      bottom: 0;
      width: calc(100% - 40px);
      left: 20px;
      background: transparent;
      text-align: center;
      padding: 10px 0;
      font-size: 1em;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
      z-index: 10;
    }
    #footer-info p {
      margin: 0;
      display: inline;
    }
    #footer-info a {
      color: white;
      text-decoration: underline;
      margin-left: 5px;
      cursor: pointer;
    }
    
    /* Keyboard Shortcuts Modal */
    #shortcuts-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #shortcuts-modal > div {
      background: #1e1e1e;
      border: 1px solid rgba(223,197,136,0.8);
      padding: 20px;
      border-radius: 8px;
      color: white;
      min-width: 300px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    #shortcuts-modal h3 {
      text-align: center;
      margin-bottom: 15px;
    }
    #shortcuts-modal table {
      width: 100%;
      border-collapse: collapse;
    }
    #shortcuts-modal tr {
      border-bottom: 1px solid rgba(223,197,136,0.5);
    }
    #shortcuts-modal th {
      text-align: left;
      padding: 8px;
    }
    #shortcuts-modal td {
      padding: 8px;
    }
    #shortcuts-modal td:last-child {
      text-align: right;
    }
    #shortcuts-modal button {
      padding: 8px 15px;
      background: rgba(223,197,136,0.8);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 15px;
    }
    
    /* Tutorial System */
    #tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      display: none;
    }
    .tutorial-step {
      position: absolute;
      background: rgba(30,30,30,0.95);
      border: 2px solid rgba(223,197,136,0.8);
      border-radius: 8px;
      padding: 15px;
      width: 300px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      z-index: 1001;
      font-family: Arial, sans-serif;
      display: none;
    }
    .tutorial-step h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: rgba(223,197,136,0.8);
    }
    .tutorial-step p {
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .tutorial-nav {
      display: flex;
      justify-content: space-between;
    }
    .tutorial-nav button {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      background: rgba(223,197,136,0.8);
      color: #1e1e1e;
      cursor: pointer;
    }
    
    /* Enhanced Responsive adjustments */
    /* Large Desktop (Default) */
    /* Medium Desktop */
    @media screen and (max-width: 1366px) {
      #toolbox {
        top: 80px;
      }
      #right-menus {
        top: 80px;
      }
    }
    
    /* Small Desktop/Tablet Landscape */
    @media screen and (max-width: 1024px) {
      #header-logo h1 {
        font-size: 0.9em;
      }
      .tool {
        width: 45px;
        height: 45px;
      }
      #toolbox {
        gap: 8px;
        padding: 8px;
      }
      .menu-container {
        width: 160px;
      }
      /* Make sure the hidden class still works */
      .menu-container.hidden {
        transform: translateX(109%) !important;
      }
      #admin-panel {
        width: 280px;
      }
    }
    
    /* Tablet Portrait */
    @media screen and (max-width: 768px) {
      #header-logo h1 {
        font-size: 0.8em;
        padding: 0 10px;
      }
      .tool {
        width: 40px;
        height: 40px;
      }
      .menu-toggle {
        left: -35px;
      }
      #right-menus {
        top: 70px;
      }
      /* Make sure the hidden class still works */
      .menu-container.hidden {
        transform: translateX(109%) !important;
      }
      #toolbox {
        top: 70px;
        padding: 6px;
        gap: 6px;
      }
      #admin-panel {
        width: 250px;
        bottom: 60px;
        right: 15px;
      }
      #footer-info {
        font-size: 0.9em;
      }
      
      /* Change tooltip position for smaller screens */
      .tool::after {
        top: -25px;
        left: 50%;
        transform: translateX(-50%);
      }
    }
    
    /* Large Mobile */
    @media screen and (max-width: 576px) {
      #header-logo h1 {
        font-size: 0.7em;
      }
      .tool {
        width: 35px;
        height: 35px;
      }
      #toolbox {
        left: 10px;
        padding: 5px;
        gap: 5px;
      }
      #right-menus {
        right: 10px;
      }
      .menu-container {
        width: 140px;
      }
      /* Make sure the hidden class still works */
      .menu-container.hidden {
        transform: translateX(109%) !important;
      }
      .menu-toggle {
        left: -30px;
        font-size: 0.9em;
      }
      .menu-content button {
        height: 35px;
        font-size: 0.9em;
      }
      #color-grid {
        grid-template-columns: repeat(4, 1fr);
      }
      #admin-panel {
        width: 90%;
        right: 5%;
        left: 5%;
      }
      #admin-panel header h3 {
        font-size: 1.4em;
      }
      #footer-info {
        font-size: 0.8em;
        width: 100%;
        left: 0;
        padding: 5px;
      }
      /* Login screen adjustments */
      #login-screen input {
        width: 80%;
        max-width: 250px;
      }
    }
    
    /* Small Mobile */
    @media screen and (max-width: 375px) {
      #header-logo h1 {
        font-size: 0.6em;
      }
      .tool {
        width: 30px;
        height: 30px;
      }
      #toolbox {
        gap: 4px;
        padding: 4px;
      }
      .menu-container {
        width: 130px;
      }
      /* Make sure the hidden class still works */
      .menu-container.hidden {
        transform: translateX(109%) !important;
      }
      #footer-info p {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px;
      }
    }
    
    /* Portrait/Landscape specific adjustments */
    @media screen and (max-height: 600px) {
      #toolbox {
        top: 60px;
      }
      #right-menus {
        top: 60px;
      }
      #header-logo {
        padding: 5px 0;
      }
    }
    
    /* Touch device enhancements */
    @media (pointer: coarse) {
      .tool, button {
        min-height: 44px; /* Minimum touch target size */
      }
      .tool::after {
        display: none; /* Hide tooltips on touch devices */
      }
      /* Add a touch indicator button for tooltips */
      .tool-info {
        position: absolute;
        top: 2px;
        right: 2px;
        width: 12px;
        height: 12px;
        background: rgba(223,197,136,0.8);
        border-radius: 50%;
        z-index: 5;
      }
    }

    /* Chat panel styles - UPDATED for improved functionality */
    #chat-panel {
      position: fixed;
      bottom: 60px;
      right: 20px;
      width: 300px;
      background: rgba(30,30,30,0.9);
      border: 1px solid rgba(223,197,136,0.5);
      border-radius: 5px 5px 0 0;
      box-shadow: 0 0 10px rgba(223,197,136,0.5);
      z-index: 25;
      display: none;
    }
    #chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid rgba(223,197,136,0.5);
      cursor: pointer;
    }
    #chat-header h3 {
      margin: 0;
      font-size: 1.2em;
    }
    #chat-header .chat-controls {
      display: flex;
      gap: 10px;
    }
    #chat-toggle, #chat-close {
      background: none;
      border: none;
      color: rgba(223,197,136,0.8);
      cursor: pointer;
      font-size: 1.2em;
    }
    #chat-messages {
      height: 200px;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .chat-message {
      padding: 5px 8px;
      border-radius: 5px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .chat-message.sent {
      align-self: flex-end;
      background: rgba(223,197,136,0.8);
      color: #1e1e1e;
    }
    .chat-message.received {
      align-self: flex-start;
      background: rgba(60,60,60,0.8);
      color: white;
    }
    .chat-user {
      font-size: 0.8em;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    #chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid rgba(223,197,136,0.5);
    }
    #chat-input input {
      flex-grow: 1;
      padding: 5px;
      border: 1px solid rgba(223,197,136,0.5);
      border-radius: 3px;
      background: rgba(50,50,50,0.9);
      color: white;
    }
    #chat-input button {
      margin-left: 5px;
      padding: 5px 10px;
      border: none;
      border-radius: 3px;
      background: rgba(223,197,136,0.8);
      color: #1e1e1e;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Animated waves background using WebGL -->
  <div id="background-container">
    <canvas id="waveCanvas"></canvas>
  </div>

  <!-- Loading overlay -->
  <div id="loading-overlay">
    <img src="https://regnumsolis.com/planner/images/loading.gif" alt="Loading" />
    <div id="loading-text">0%</div>
  </div>

  <!-- Color Picker Modal -->
  <div id="color-picker-modal">
    <h3>Select a Color</h3>
    <div id="color-grid"></div>
    <button id="color-picker-close">Close</button>
  </div>

  <!-- Login Screen -->
  <div id="login-screen">
    <h2>Login</h2>
    <input id="email" type="email" placeholder="Email" />
    <input id="password" type="password" placeholder="Password" />
    <button id="login-button">Login</button>
    <div id="login-error"></div>
  </div>

  <!-- Main App -->
  <div id="app">
    <!-- Header -->
    <div id="header-logo">
      <h1>Regnum Solis Research and Development for the Remnant Senate</h1>
    </div>

    <!-- Search Function -->
    <div id="search-container">
      <input id="search-input" type="text" placeholder="Search markers..." />
      <button id="search-button">🔍</button>
      <div id="search-results"></div>
    </div>

    <!-- Undo/Redo History Controls -->
    <div id="history-controls">
      <button id="undo-button" title="Undo (Ctrl+Z)">↩</button>
      <button id="redo-button" title="Redo (Ctrl+Y)">↪</button>
    </div>

    <!-- Right-side menus container -->
    <div id="right-menus">
      <!-- Map Change Menu -->
      <div id="map-change-container" class="menu-container hidden">
        <div class="menu-header">
          <span>Change Maps</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <button id="tactical-map">Tactical Map</button>
          <button id="style-map">Style Map</button>
        </div>
      </div>

      <!-- Settings Menu with toggles -->
      <div id="settings-container" class="menu-container hidden">
        <div class="menu-header">
          <span>Settings</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <div id="toggle-container">
            <input type="checkbox" id="toggle-marker-text" class="toggle-switch" />
            <label for="toggle-marker-text" id="toggle-marker-text-label">Text on Hover</label>
          </div>
          <div id="marker-visibility-container">
            <h3>Marker Visibility</h3>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-homestead" class="toggle-switch" checked />
              <label for="toggle-homestead">Homestead</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-keep" class="toggle-switch" checked />
              <label for="toggle-keep">Keep</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-torch" class="toggle-switch" checked />
              <label for="toggle-torch">Torch</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-cave" class="toggle-switch" checked />
              <label for="toggle-cave">Cave</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-sword" class="toggle-switch" checked />
              <label for="toggle-sword">Sword</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-spear" class="toggle-switch" checked />
              <label for="toggle-spear">Spear</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-bow" class="toggle-switch" checked />
              <label for="toggle-bow">Bow</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-beacon" class="toggle-switch" checked />
              <label for="toggle-beacon">Beacon</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-camp" class="toggle-switch" checked />
              <label for="toggle-camp">Camp</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-catapult" class="toggle-switch" checked />
              <label for="toggle-catapult">Catapult</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-ram" class="toggle-switch" checked />
              <label for="toggle-ram">Ram</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-lines" class="toggle-switch" checked />
              <label for="toggle-lines">Lines</label>
            </div>
          </div>
        </div>
      </div>

      <!-- Action Buttons Menu -->
      <div id="action-buttons" class="menu-container hidden">
        <div class="menu-header">
          <span>Actions</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <button id="toggle-chat">Open Chat</button>
          <button id="start-tutorial">Tutorial</button>
          <button id="show-shortcuts">Keyboard Shortcuts</button>
        </div>
      </div>
    </div>

    <!-- Toolbox -->
    <div id="toolbox">
      <!-- Color Bucket Tool -->
      <div class="tool" data-type="color" data-tooltip="Change Color">
        <svg id="paint-bucket-svg" viewBox="0 0 64 64">
          <!-- Bucket outline -->
          <path d="M12 20 L52 20 L44 50 L20 50 Z" stroke="white" stroke-width="2" fill="none" />
          <!-- Paint inside the bucket -->
          <rect id="paint-fill" x="16" y="24" width="32" height="12" fill="#dfc588" />
        </svg>
      </div>
      
      <!-- Bezier Tool -->
      <div class="tool" data-type="bezier" data-tooltip="Draw Bezier Curve">
        <svg width="50" height="50" viewBox="0 0 50 50">
          <path d="M10 40 Q25 10 40 40" stroke="white" stroke-width="3" fill="none" />
        </svg>
      </div>
      
      <!-- Polygon Tool -->
      <div class="tool" data-type="polygon" data-tooltip="Draw Polygon">
        <svg width="50" height="50" viewBox="0 0 50 50">
          <polygon points="25,10 10,40 40,40" stroke="white" stroke-width="3" fill="none" />
        </svg>
      </div>
      
      <!-- Basic markers -->
      <div class="tool" draggable="true" data-type="torch" data-tooltip="Place Torch">
        <img src="https://regnumsolis.com/planner/images/torch.svg" alt="Torch" />
      </div>
      <div class="tool" draggable="true" data-type="keep" data-tooltip="Place Keep">
        <img src="https://regnumsolis.com/planner/images/citadel.svg" alt="Keep" />
      </div>
      <div class="tool" draggable="true" data-type="homestead" data-tooltip="Place Homestead">
        <img src="https://regnumsolis.com/planner/images/marker.svg" alt="Homestead" />
      </div>
      <div class="tool" draggable="true" data-type="camp" data-tooltip="Place Camp">
        <img src="https://regnumsolis.com/planner/images/camp.svg" alt="Camp" />
      </div>
      <div class="tool" draggable="true" data-type="beacon" data-tooltip="Place Beacon">
        <img src="https://regnumsolis.com/planner/images/beacon.svg" alt="Beacon" />
      </div>
      <div class="tool" draggable="true" data-type="cave" data-tooltip="Place Cave">
        <img src="https://regnumsolis.com/planner/images/cave.svg" alt="Cave" />
      </div>
      <div class="tool" draggable="true" data-type="sword" data-tooltip="Place Sword">
        <img src="https://regnumsolis.com/planner/images/sword.svg" alt="Sword" />
      </div>
      <div class="tool" draggable="true" data-type="spear" data-tooltip="Place Spear">
        <img src="https://regnumsolis.com/planner/images/spear.svg" alt="Spear" />
      </div>
      <div class="tool" draggable="true" data-type="bow" data-tooltip="Place Bow">
        <img src="https://regnumsolis.com/planner/images/bow.svg" alt="Bow" />
      </div>
      <div class="tool" draggable="true" data-type="catapult" data-tooltip="Place Catapult">
        <img src="https://regnumsolis.com/planner/images/catapult.svg" alt="Catapult" />
      </div>
      <div class="tool" draggable="true" data-type="ram" data-tooltip="Place Ram">
        <img src="https://regnumsolis.com/planner/images/ram.svg" alt="Ram" />
      </div>
    </div>

    <!-- Map Container -->
    <div id="map-container">
      <div id="map-svg-container"></div>
    </div>

    <!-- Chat Panel -->
    <div id="chat-panel">
      <div id="chat-header">
        <h3>Team Chat</h3>
        <div class="chat-controls">
          <button id="chat-toggle">−</button>
          <button id="chat-close">×</button>
        </div>
      </div>
      <div id="chat-messages">
        <!-- Messages will be added dynamically -->
        <div class="chat-message received">
          <div class="chat-user">System</div>
          <div>Welcome to the planning session!</div>
        </div>
      </div>
      <div id="chat-input">
        <input type="text" placeholder="Type your message...">
        <button>Send</button>
      </div>
    </div>

    <!-- Admin Panel -->
    <div id="admin-panel">
      <header>
        <h3>Admin Panel</h3>
        <div class="admin-controls">
          <button id="minimize-panel" title="Minimize/Maximize">➖</button>
          <button id="copy-log" title="Copy Audit Log">📋</button>
          <button id="clear-logs" title="Delete All Audit Logs">🗑️</button>
        </div>
      </header>
      <div id="audit-log-container"></div>
      <footer>
        <button id="delete-all-markers">Delete All Markers</button>
        <button id="clear-chat">Clear Chat</button>
      </footer>
    </div>

    <!-- Tutorial System -->
    <div id="tutorial-overlay">
      <div class="tutorial-step" data-step="1" style="top: 100px; left: 100px;">
        <h3>Welcome to SOLIS Planner</h3>
        <p>This tutorial will guide you through the basic features of the tactical planning tool.</p>
        <div class="tutorial-nav">
          <button data-action="skip">Skip Tutorial</button>
          <button data-action="next">Next</button>
        </div>
      </div>
      <div class="tutorial-step" data-step="2" style="top: 100px; left: 300px;">
        <h3>Using Markers</h3>
        <p>Drag markers from the toolbox to place them on the map. Click on markers to delete them.</p>
        <div class="tutorial-nav">
          <button data-action="prev">Previous</button>
          <button data-action="next">Next</button>
        </div>
      </div>
      <div class="tutorial-step" data-step="3" style="top: 100px; left: 300px;">
        <h3>Drawing Tools</h3>
        <p>Use the bezier and polygon tools to create tactical movement paths and areas. Right-click to finish drawing.</p>
        <div class="tutorial-nav">
          <button data-action="prev">Previous</button>
          <button data-action="next">Next</button>
        </div>
      </div>
      <div class="tutorial-step" data-step="4" style="top: 100px; left: 300px;">
        <h3>Search Feature</h3>
        <p>Use the search box at the top to quickly find markers on your map.</p>
        <div class="tutorial-nav">
          <button data-action="prev">Previous</button>
          <button data-action="done">Finish</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div id="shortcuts-modal">
    <div>
      <h3>Keyboard Shortcuts</h3>
      <table>
        <tr>
          <th>Action</th>
          <th>Shortcut</th>
        </tr>
        <tr>
          <td>Undo</td>
          <td>Ctrl+Z</td>
        </tr>
        <tr>
          <td>Redo</td>
          <td>Ctrl+Y</td>
        </tr>
        <tr>
          <td>Delete Selected</td>
          <td>Delete</td>
        </tr>
        <tr>
          <td>Search</td>
          <td>Ctrl+F</td>
        </tr>
        <tr>
          <td>Help</td>
          <td>F1</td>
        </tr>
      </table>
      <div style="text-align: center;">
        <button id="close-shortcuts">Close</button>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer id="footer-info">
    <p>
      Build version: v2.0.0 |
      Encrypted database connection: <span id="db-connection-status">🟢</span> |
      Status: <span id="user-status">user</span> |
      <a href="https://regnumsolis.com">Return to Home</a> |
      <a id="show-shortcuts-footer">Keyboard Shortcuts</a>
    </p>
  </footer>

  <div id="error-overlay">Database connection failed. The app cannot be used at this time.</div>

  <!-- Custom Prompt Modal -->
  <div id="custom-prompt-overlay" style="display:none; position: fixed; top: 0; left: 0; width:100%; height:100%; background: rgba(0,0,0,0.5); backdrop-filter: blur(5px); align-items: center; justify-content: center; z-index: 2000;">
    <div id="custom-prompt" style="background: #1e1e1e; border: 1px solid rgba(223,197,136,0.8); padding: 20px; border-radius: 8px; color: white; min-width: 300px; max-width: 90%; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
      <p id="custom-prompt-message" style="margin-bottom: 15px; width:100%;"></p>
      <input id="custom-prompt-input" type="text" style="width: 80%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 15px; text-align: center;" />
      <div style="display: flex; justify-content: center; gap: 10px; width: 100%;">
        <button id="custom-prompt-ok" style="padding: 8px 15px; background: rgba(223,197,136,0.8); border: none; border-radius: 4px; cursor: pointer;">OK</button>
        <button id="custom-prompt-cancel" style="padding: 8px 15px; background: rgba(223,197,136,0.8); border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, orderBy, query, onSnapshot, deleteDoc, doc, serverTimestamp, getDocs, getDoc, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";

    // Global selected color for tools. Default is set to "#dfc588"
    let selectedColor = "#dfc588";

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAIws_FKV_CTaiHdnwc8WigDqRkyUCOjtE",
      authDomain: "regnum-d3ddf.firebaseapp.com",
      projectId: "regnum-d3ddf",
      storageBucket: "regnum-d3ddf.firebasestorage.app",
      messagingSenderId: "565532905074",
      appId: "1:565532905074:web:a4cc38363376e49540fceb",
      measurementId: "G-4RG5NP4FZ3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    let panZoomInstance, svgRoot, panLayer, lineLayer, markerLayer, textLayer;
    let isMapReady = false;
    let activeTool = null;
    
    // Globals for Bezier and Polygon tools
    let bezierControlPoints = [];
    let polygonVertices = [];
    let currentBezierPath = null;
    let currentPolygonElement = null;
    
    // Variable to prevent duplicate delete confirmations
    let isDeleteInProgress = false;
    
    // Updated History System - Including database operations
    let historyStack = [];
    let historyIndex = -1;
    let isUndoRedoAction = false;
    
    // Global visibility state
    const visibilityState = {
      homestead: true, keep: true, torch: true, cave: true,
      sword: true, spear: true, bow: true, beacon: true,
      camp: true, catapult: true, ram: true, lines: true
    };

    // Update marker visibility functions
    function updateMarkerVisibility() {
      markerLayer.querySelectorAll("[data-marker='true']").forEach(markerEl => {
        const type = markerEl.getAttribute("data-type");
        markerEl.style.display = visibilityState[type] ? "" : "none";
      });
    }
    
    function updateLineVisibility() {
      lineLayer.style.display = visibilityState.lines ? "" : "none";
    }

    // Loading animation
    let loadingInterval;
    let currentProgress = 0;
    const loadingOverlay = document.getElementById("loading-overlay");
    const loadingText = document.getElementById("loading-text");

    // Initialize the application once DOM is ready
    document.addEventListener("DOMContentLoaded", () => {
      setupLogin();
      setupToolbox();
      setupMapSwitchControls();
      setupMenuToggles();
      setupAdminPanelControls();
      setupColorPicker();
      setupUndoRedoSystem();
      setupChatSystem();
      setupSearchFunction();
      setupKeyboardShortcuts();
      setupTutorial();

      // Toggle for text hover behavior
      const toggleMarkerTextCheckbox = document.getElementById("toggle-marker-text");
      const toggleLabel = document.getElementById("toggle-marker-text-label");
      toggleMarkerTextCheckbox.addEventListener("change", function() {
        if (this.checked) {
          document.body.classList.add("text-hover-only");
          toggleLabel.textContent = "Text on Hover";
        } else {
          document.body.classList.remove("text-hover-only");
          toggleLabel.textContent = "All Text Active";
        }
      });

      // Set up visibility state toggle handlers
      Object.keys(visibilityState).forEach(key => {
        const checkbox = document.getElementById(`toggle-${key}`);
        if (checkbox) {
          checkbox.addEventListener("change", function() {
            visibilityState[key] = this.checked;
            if (key === "lines") updateLineVisibility();
            else updateMarkerVisibility();
          });
        }
      });

      // Add touch detection for better mobile support
      if ('ontouchstart' in window) {
        document.body.classList.add('touch-device');
        // Add info buttons to tools for touch devices
        document.querySelectorAll('.tool').forEach(tool => {
          const infoBtn = document.createElement('div');
          infoBtn.className = 'tool-info';
          tool.appendChild(infoBtn);
        });
      }

      // Ensure menus stay hidden on window resize
      window.addEventListener('resize', function() {
        document.querySelectorAll(".menu-container.hidden").forEach(menu => {
          menu.style.transform = "translateX(109%)";
        });
        
        // Update canvas size for WebGL background
        const canvas = document.getElementById('waveCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Reset pan/zoom on significant resize
        if (panZoomInstance && isMapReady) {
          panZoomInstance.resetZoom();
        }
      });

      // Keyboard shortcuts for search
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "f") {
          e.preventDefault();
          document.getElementById("search-input").focus();
        }
      });
    });
    
    // Set up Undo/Redo System with Database Integration
    function setupUndoRedoSystem() {
      document.getElementById("undo-button").addEventListener("click", performUndo);
      document.getElementById("redo-button").addEventListener("click", performRedo);
      
      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "z") {
          e.preventDefault();
          performUndo();
        } else if (e.ctrlKey && e.key === "y") {
          e.preventDefault();
          performRedo();
        }
      });
      
      // Load history from database on startup
      loadHistoryFromDatabase();
      
      // Update button states
      updateUndoRedoButtons();
    }
    
    async function loadHistoryFromDatabase() {
      try {
        const historyQuery = query(collection(db, "history"), orderBy("timestamp"));
        const snapshot = await getDocs(historyQuery);
        
        historyStack = [];
        snapshot.forEach(doc => {
          historyStack.push({
            id: doc.id,
            ...doc.data()
          });
        });
        
        // Set index to most recent state
        historyIndex = historyStack.length - 1;
        updateUndoRedoButtons();
        
        // Also load current index from metadata if available
        const metadataDoc = await getDoc(doc(db, "historyMetadata", "current"));
        if (metadataDoc.exists()) {
          const data = metadataDoc.data();
          if (data.currentIndex !== undefined && data.currentIndex >= 0 && data.currentIndex < historyStack.length) {
            historyIndex = data.currentIndex;
            
            // Apply the current state
            if (historyStack[historyIndex]) {
              await applyHistoryState(historyStack[historyIndex]);
            }
          }
        }
        
        updateUndoRedoButtons();
      } catch (error) {
        console.error("Error loading history:", error);
      }
    }
    
    async function performUndo() {
      if (historyIndex > 0) {
        historyIndex--;
        isUndoRedoAction = true;
        
        try {
          // Get previous state from history
          const previousState = historyStack[historyIndex];
          
          // Apply previous state
          await applyHistoryState(previousState);
          
          // Update database with current history index
          await updateDoc(doc(db, "historyMetadata", "current"), {
            currentIndex: historyIndex,
            timestamp: serverTimestamp()
          });
          
          updateUndoRedoButtons();
          recordAuditLog("undo", { toStateId: previousState.id });
        } catch (error) {
          console.error("Error performing undo:", error);
          isUndoRedoAction = false;
        }
      }
    }
    
    async function performRedo() {
      if (historyIndex < historyStack.length - 1) {
        historyIndex++;
        isUndoRedoAction = true;
        
        try {
          // Get next state from history
          const nextState = historyStack[historyIndex];
          
          // Apply next state
          await applyHistoryState(nextState);
          
          // Update database with current history index
          await updateDoc(doc(db, "historyMetadata", "current"), {
            currentIndex: historyIndex,
            timestamp: serverTimestamp()
          });
          
          updateUndoRedoButtons();
          recordAuditLog("redo", { toStateId: nextState.id });
        } catch (error) {
          console.error("Error performing redo:", error);
          isUndoRedoAction = false;
        }
      }
    }
    
    async function applyHistoryState(state) {
      // Implementation to restore the map to a previous state
      // This would involve clearing all existing elements and recreating them
      // from the stored state data
      
      try {
        // Clear current map elements
        clearAllElements();
        
        // Recreate elements from state
        if (state.markers) {
          state.markers.forEach(marker => {
            createMarkerElement(marker.id, marker);
          });
        }
        
        if (state.lines) {
          state.lines.forEach(line => {
            createLineElement(line.id, line);
          });
        }
        
        if (state.bezierCurves) {
          state.bezierCurves.forEach(curve => {
            createBezierElement(curve.id, curve);
          });
        }
        
        if (state.polygons) {
          state.polygons.forEach(polygon => {
            createPolygonElement(polygon.id, polygon);
          });
        }
        
        // Update visibility
        updateMarkerVisibility();
        updateLineVisibility();
        
      } catch (error) {
        console.error("Error applying history state:", error);
      } finally {
        isUndoRedoAction = false;
      }
    }
    
    function clearAllElements() {
      // Clear all elements from the map
      while (markerLayer.firstChild) {
        markerLayer.removeChild(markerLayer.firstChild);
      }
      
      while (lineLayer.firstChild) {
        lineLayer.removeChild(lineLayer.firstChild);
      }
      
      while (textLayer.firstChild) {
        textLayer.removeChild(textLayer.firstChild);
      }
    }
    
    async function createHistoryEntry() {
      // Skip if we're in the middle of an undo/redo action
      if (isUndoRedoAction) {
        isUndoRedoAction = false;
        return;
      }
      
      try {
        // Capture current state
        const currentState = captureState();
        
        // Add to Firestore
        const docRef = await addDoc(collection(db, "history"), {
          ...currentState,
          timestamp: serverTimestamp()
        });
        
        // If we're in the middle of the stack, remove everything after current index
        if (historyIndex < historyStack.length - 1) {
          // Remove from database
          const toRemove = historyStack.slice(historyIndex + 1);
          const deletePromises = toRemove.map(state => 
            deleteDoc(doc(db, "history", state.id))
          );
          await Promise.all(deletePromises);
          
          // Update local stack
          historyStack = historyStack.slice(0, historyIndex + 1);
        }
        
        // Add to history stack
        historyStack.push({
          id: docRef.id,
          ...currentState
        });
        
        // Update index
        historyIndex = historyStack.length - 1;
        
        // Update database with current history index
        await setDoc(doc(db, "historyMetadata", "current"), {
          currentIndex: historyIndex,
          timestamp: serverTimestamp()
        });
        
        updateUndoRedoButtons();
        recordAuditLog("create_history", { stateId: docRef.id });
      } catch (error) {
        console.error("Error creating history entry:", error);
      }
    }
    
    function captureState() {
      // Capture current map state
      const state = {
        markers: [],
        lines: [],
        bezierCurves: [],
        polygons: []
      };
      
      // Capture markers
      markerLayer.querySelectorAll("[data-marker='true']").forEach(marker => {
        const id = marker.dataset.id;
        const type = marker.dataset.type;
        const text = marker.querySelector("text")?.textContent || "";
        const color = marker.querySelector("text")?.getAttribute("fill") || "#dfc588";
        const imgEl = marker.querySelector("image");
        const x = parseFloat(imgEl.getAttribute("x")) + parseFloat(imgEl.getAttribute("width")) / 2;
        const y = parseFloat(imgEl.getAttribute("y")) + parseFloat(imgEl.getAttribute("height")) / 2;
        
        state.markers.push({
          id, type, text, color, x, y
        });
      });
      
      // Capture lines
      lineLayer.querySelectorAll(".line-group").forEach(group => {
        const id = group.dataset.id;
        const line = group.querySelector("line");
        const x1 = parseFloat(line.getAttribute("x1"));
        const y1 = parseFloat(line.getAttribute("y1"));
        const x2 = parseFloat(line.getAttribute("x2"));
        const y2 = parseFloat(line.getAttribute("y2"));
        const color = line.getAttribute("stroke");
        
        const arrow = group.querySelector("polygon");
        const transform = arrow.getAttribute("transform");
        const midXMatch = transform.match(/translate\(([-\d.]+),([-\d.]+)\)/);
        const angleMatch = transform.match(/rotate\(([-\d.]+)\)/);
        
        const midX = midXMatch ? parseFloat(midXMatch[1]) : (x1 + x2) / 2;
        const midY = midXMatch ? parseFloat(midXMatch[2]) : (y1 + y2) / 2;
        const angle = angleMatch ? parseFloat(angleMatch[1]) : 0;
        
        state.lines.push({
          id, x1, y1, x2, y2, midX, midY, angle, color
        });
      });
      
      // Capture bezier curves
      lineLayer.querySelectorAll("g[data-bezier='true']").forEach(bezier => {
        const id = bezier.dataset.id;
        const path = bezier.querySelector("path");
        const color = path.getAttribute("stroke");
        
        // Extract control points - in a real implementation, you would need
        // to store these when creating/loading beziers
        const controlPoints = [];
        
        state.bezierCurves.push({
          id, color, controlPoints
        });
      });
      
      // Capture polygons
      lineLayer.querySelectorAll("polygon[data-polygon='true']").forEach(polygon => {
        const id = polygon.dataset.id;
        const pointsStr = polygon.getAttribute("points");
        const color = polygon.getAttribute("stroke");
        
        const vertices = pointsStr.trim().split(" ").map(pair => {
          const [x, y] = pair.split(",").map(parseFloat);
          return { x, y };
        });
        
        state.polygons.push({
          id, vertices, color
        });
      });
      
      return state;
    }
    
    function updateUndoRedoButtons() {
      document.getElementById("undo-button").disabled = historyIndex <= 0;
      document.getElementById("redo-button").disabled = historyIndex >= historyStack.length - 1;
    }
    
    // Set up Search Function
    function setupSearchFunction() {
      const searchInput = document.getElementById("search-input");
      const searchButton = document.getElementById("search-button");
      const searchResults = document.getElementById("search-results");
      
      searchButton.addEventListener("click", performSearch);
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          performSearch();
        }
      });
    }
    
    function performSearch() {
      const searchInput = document.getElementById("search-input");
      const searchResults = document.getElementById("search-results");
      const query = searchInput.value.trim().toLowerCase();
      
      if (!query) return;
      
      searchResults.innerHTML = "";
      let resultsFound = false;
      
      // Search markers
      markerLayer.querySelectorAll("[data-marker='true']").forEach(marker => {
        const text = marker.querySelector("text")?.textContent?.toLowerCase() || "";
        const type = marker.dataset.type?.toLowerCase() || "";
        
        if (text.includes(query) || type.includes(query)) {
          addSearchResult(marker, text || type, searchResults);
          resultsFound = true;
        }
      });
      
      // Search text labels
      textLayer.querySelectorAll(".text-label").forEach(textLabel => {
        const text = textLabel.querySelector("text")?.textContent?.toLowerCase() || "";
        
        if (text.includes(query)) {
          addSearchResult(textLabel, text, searchResults);
          resultsFound = true;
        }
      });
      
      if (resultsFound) {
        searchResults.style.display = "block";
      } else {
        searchResults.innerHTML = "<div class='search-result'>No results found</div>";
        searchResults.style.display = "block";
      }
    }
    
    function addSearchResult(element, text, resultsContainer) {
      const resultItem = document.createElement("div");
      resultItem.className = "search-result";
      resultItem.textContent = text;
      resultItem.addEventListener("click", () => {
        // Center view on the element
        const bbox = element.getBBox();
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        panZoomInstance.pan({ x: -centerX + window.innerWidth / 2, y: -centerY + window.innerHeight / 2 });
        
        // Hide search results
        resultsContainer.style.display = "none";
      });
      
      resultsContainer.appendChild(resultItem);
    }
    
    // Set up Keyboard Shortcuts
    function setupKeyboardShortcuts() {
      document.getElementById("show-shortcuts").addEventListener("click", () => {
        document.getElementById("shortcuts-modal").style.display = "flex";
      });
      
      document.getElementById("show-shortcuts-footer").addEventListener("click", () => {
        document.getElementById("shortcuts-modal").style.display = "flex";
      });
      
      document.getElementById("close-shortcuts").addEventListener("click", () => {
        document.getElementById("shortcuts-modal").style.display = "none";
      });
      
      // Global keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        // F1 for help
        if (e.key === "F1") {
          e.preventDefault();
          document.getElementById("shortcuts-modal").style.display = "flex";
        }
      });
    }
    
    // Set up Tutorial
    function setupTutorial() {
      document.getElementById("start-tutorial").addEventListener("click", startTutorial);
      
      // Set up tutorial step navigation
      document.querySelectorAll(".tutorial-step [data-action]").forEach(button => {
        button.addEventListener("click", (e) => {
          const action = e.target.dataset.action;
          const currentStep = e.target.closest(".tutorial-step");
          const currentStepNumber = parseInt(currentStep.dataset.step);
          
          if (action === "next") {
            currentStep.style.display = "none";
            document.querySelector(`.tutorial-step[data-step="${currentStepNumber + 1}"]`).style.display = "block";
          } else if (action === "prev") {
            currentStep.style.display = "none";
            document.querySelector(`.tutorial-step[data-step="${currentStepNumber - 1}"]`).style.display = "block";
          } else if (action === "skip" || action === "done") {
            endTutorial();
          }
        });
      });
    }
    
    function startTutorial() {
      document.getElementById("tutorial-overlay").style.display = "block";
      document.querySelector(".tutorial-step[data-step='1']").style.display = "block";
    }
    
    function endTutorial() {
      document.getElementById("tutorial-overlay").style.display = "none";
      document.querySelectorAll(".tutorial-step").forEach(step => {
        step.style.display = "none";
      });
    }
    
    // Set up Chat System with Database Integration
    function setupChatSystem() {
      // Show chat when button is clicked
      document.getElementById("toggle-chat").addEventListener("click", () => {
        document.getElementById("chat-panel").style.display = "block";
      });
      
      document.getElementById("chat-toggle").addEventListener("click", toggleChat);
      document.getElementById("chat-close").addEventListener("click", closeChat);
      
      const chatInput = document.getElementById("chat-input").querySelector("input");
      const sendButton = document.getElementById("chat-input").querySelector("button");
      
      sendButton.addEventListener("click", sendChatMessage);
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          sendChatMessage();
        }
      });
      
      // Add event listener for clear chat button
      document.getElementById("clear-chat").addEventListener("click", clearChatHistory);
      
      // Listen for new messages
      const chatQuery = query(collection(db, "chatMessages"), orderBy("timestamp"));
      onSnapshot(chatQuery, (snapshot) => {
        snapshot.docChanges().forEach(change => {
          if (change.type === "added") {
            const msg = change.doc.data();
            addChatMessage(msg.user, msg.text, msg.userId === auth.currentUser?.uid);
          }
        });
      });
    }
    
    function toggleChat() {
      const chatMessages = document.getElementById("chat-messages");
      const chatToggle = document.getElementById("chat-toggle");
      
      if (chatMessages.style.display === "none") {
        chatMessages.style.display = "flex";
        document.getElementById("chat-input").style.display = "flex";
        chatToggle.textContent = "−";
      } else {
        chatMessages.style.display = "none";
        document.getElementById("chat-input").style.display = "none";
        chatToggle.textContent = "+";
      }
    }
    
    function closeChat() {
      document.getElementById("chat-panel").style.display = "none";
    }
    
    function sendChatMessage() {
      const chatInput = document.getElementById("chat-input").querySelector("input");
      const text = chatInput.value.trim();
      
      if (!text || !auth.currentUser) return;
      
      // Add to Firestore
      addDoc(collection(db, "chatMessages"), {
        text: text,
        user: auth.currentUser.email,
        userId: auth.currentUser.uid,
        timestamp: serverTimestamp()
      }).then(() => {
        // Success - message will be added via the onSnapshot listener
      }).catch(error => {
        console.error("Error sending message:", error);
        alert("Failed to send message. Please try again.");
      });
      
      // Clear input
      chatInput.value = "";
    }
    
    function addChatMessage(user, text, isSent) {
      const chatMessages = document.getElementById("chat-messages");
      
      const messageDiv = document.createElement("div");
      messageDiv.className = `chat-message ${isSent ? "sent" : "received"}`;
      
      const userDiv = document.createElement("div");
      userDiv.className = "chat-user";
      userDiv.textContent = user;
      
      const textDiv = document.createElement("div");
      textDiv.textContent = text;
      
      messageDiv.appendChild(userDiv);
      messageDiv.appendChild(textDiv);
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    async function clearChatHistory() {
      if (!confirm("Delete all chat messages? This cannot be undone.")) return;
      
      try {
        const chatQuery = query(collection(db, "chatMessages"));
        const snapshot = await getDocs(chatQuery);
        
        const deletePromises = [];
        snapshot.forEach(doc => {
          deletePromises.push(deleteDoc(doc.ref));
        });
        
        await Promise.all(deletePromises);
        
        // Clear chat display
        const chatMessages = document.getElementById("chat-messages");
        chatMessages.innerHTML = "";
        
        // Add system message
        addChatMessage("System", "Chat history has been cleared.", false);
        
        recordAuditLog("clear_chat", {});
      } catch (error) {
        console.error("Error clearing chat history:", error);
        alert("Failed to clear chat history. Please try again.");
      }
    }

    function setupColorPicker() {
      // Updated color palette based on the hexagonal grid in the image
      const colorGrid = document.getElementById("color-grid");
      const hexColors = [
        // Greens (top)
        "#004000", "#006000", "#008000", "#00A000", "#00C000", "#00FF00", "#80FF80",
        // Blues (top-right)
        "#000040", "#000080", "#0000C0", "#0000FF", "#4040FF", "#8080FF", "#C0C0FF",
        // Purples (right)
        "#400040", "#600060", "#800080", "#A000A0", "#C000C0", "#FF00FF", "#FF80FF",
        // Reds (bottom-right)
        "#400000", "#600000", "#800000", "#A00000", "#C00000", "#FF0000", "#FF8080",
        // Oranges and yellows (bottom)
        "#402000", "#603000", "#804000", "#A05000", "#C06000", "#FF8000", "#FFFF00",
        // Browns (bottom-left)
        "#202020", "#404020", "#606030", "#808040", "#A0A050", "#C0C060", "#E0E080",
        // Grays (center and left)
        "#000000", "#202020", "#404040", "#606060", "#808080", "#A0A0A0", "#FFFFFF",
        // Teal/Cyan (top-left)
        "#004040", "#006060", "#008080", "#00A0A0", "#00C0C0", "#00FFFF", "#80FFFF"
      ];

      // Create color cells
      hexColors.forEach(color => {
        const cell = document.createElement("div");
        cell.className = "color-cell";
        cell.style.backgroundColor = color;
        cell.addEventListener("click", () => {
          selectedColor = color;
          document.getElementById("paint-fill").setAttribute("fill", selectedColor);
          closeColorPicker();
        });
        colorGrid.appendChild(cell);
      });
      
      // Close button event
      document.getElementById("color-picker-close").addEventListener("click", closeColorPicker);
    }

    function openColorPicker() {
      document.getElementById("color-picker-modal").style.display = "block";
    }

    function closeColorPicker() {
      document.getElementById("color-picker-modal").style.display = "none";
    }

    function setupMenuToggles() {
      document.querySelectorAll(".menu-toggle").forEach(btn => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const menu = btn.closest(".menu-container");
          menu.classList.toggle("hidden");
          btn.innerHTML = menu.classList.contains("hidden") ? "&#9654;" : "&#9664;";
        });
      });
    }

    function setupAdminPanelControls() {
      const minimizeBtn = document.getElementById("minimize-panel");
      const auditContainer = document.getElementById("audit-log-container");
      let isMinimized = false;
      minimizeBtn.addEventListener("click", () => {
        if (!isMinimized) {
          auditContainer.style.display = "none";
          minimizeBtn.textContent = "➕";
          isMinimized = true;
        } else {
          auditContainer.style.display = "block";
          minimizeBtn.textContent = "➖";
          isMinimized = false;
        }
      });

      document.getElementById("copy-log").addEventListener("click", () => {
        let logText = "";
        auditContainer.querySelectorAll("div").forEach(entry => {
          logText += entry.innerText + "\n";
        });
        navigator.clipboard.writeText(logText);
      });

      document.getElementById("clear-logs").addEventListener("click", async () => {
        if (confirm("Delete all audit logs?")) {
          try {
            const auditSnapshot = await getDocs(collection(db, "auditLogs"));
            auditSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "auditLogs", docSnap.id));
            });
          } catch (error) {
            console.error("Error deleting audit logs:", error);
          }
        }
      });

      document.getElementById("delete-all-markers").addEventListener("click", async () => {
        if (confirm("Delete all markers? This cannot be undone.")) {
          try {
            const markersSnapshot = await getDocs(collection(db, "markers"));
            markersSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "markers", docSnap.id));
            });
            const linesSnapshot = await getDocs(collection(db, "lines"));
            linesSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "lines", docSnap.id));
            });
            const bezierSnapshot = await getDocs(collection(db, "bezierCurves"));
            bezierSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "bezierCurves", docSnap.id));
            });
            const polygonsSnapshot = await getDocs(collection(db, "polygons"));
            polygonsSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "polygons", docSnap.id));
            });
            
            // Create new history entry after deleting everything
            await createHistoryEntry();
            
            recordAuditLog("delete_all", {});
          } catch (error) {
            console.error("Error deleting all elements:", error);
          }
        }
      });
    }

    function showLoading() {
      currentProgress = 0;
      loadingText.textContent = "0%";
      loadingOverlay.style.display = "flex";
      loadingInterval = setInterval(() => {
        if (currentProgress < 90) {
          currentProgress += Math.floor(Math.random() * 3) + 1;
          if (currentProgress > 90) currentProgress = 90;
          loadingText.textContent = currentProgress + "%";
        }
      }, 100);
    }

    function hideLoading() {
      clearInterval(loadingInterval);
      loadingText.textContent = "100%";
      setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
      document.getElementById("db-connection-status").textContent = "🟢";
    }

    function setupLogin() {
      document.getElementById("login-button").addEventListener("click", () => {
        const email = document.getElementById("email").value.trim();
        const password = document.getElementById("password").value.trim();
        const errorDiv = document.getElementById("login-error");

        signInWithEmailAndPassword(auth, email, password)
          .then(() => {
            errorDiv.textContent = "";
            document.getElementById("login-screen").style.display = "none";
            document.getElementById("app").style.display = "block";
            initializeMap();
          })
          .catch((error) => { errorDiv.textContent = error.message; });
      });

      onAuthStateChanged(auth, (user) => {
        if (user) {
          document.getElementById("login-screen").style.display = "none";
          document.getElementById("app").style.display = "block";
          initializeMap();
          getDoc(doc(db, "admins", user.email))
            .then((docSnap) => {
              if (docSnap.exists()) {
                document.getElementById("admin-panel").style.display = "block";
                document.getElementById("user-status").textContent = "admin";
                listenForAuditLogs();
              } else {
                console.log("User is not an admin according to Firestore");
                document.getElementById("user-status").textContent = "user";
              }
            })
            .catch((err) => console.error("Error checking admin status:", err));
        } else {
          document.getElementById("login-screen").style.display = "flex";
          document.getElementById("app").style.display = "none";
        }
      });
    }

    function initializeMap() { 
      switchMap("https://regnumsolis.com/planner/images/mvmvmdfs.svg");
    }

    function switchMap(url) {
      if (panZoomInstance) { panZoomInstance.destroy(); }
      isMapReady = false;
      const container = document.getElementById("map-svg-container");
      showLoading();
      fetch(url)
        .then(response => response.text())
        .then(svgText => {
          container.innerHTML = svgText;
          setupPanZoomLayers();
          setupDragAndDrop();
          setupDrawingTools();
          listenForMarkers();
          listenForLines();
          listenForBezierCurves();
          listenForPolygons();
          isMapReady = true;
          hideLoading();
          
          // Create initial history entry
          createHistoryEntry();
        })
        .catch(error => {
          console.error("Error loading SVG:", error);
          displayErrorOverlay("Error loading map data.");
          hideLoading();
          document.getElementById("db-connection-status").textContent = "🔴";
        });
    }

    function setupMapSwitchControls() {
      document.getElementById("tactical-map").addEventListener("click", () => {
        switchMap("https://regnumsolis.com/planner/images/mvmvmdfstactical.svg");
      });
      document.getElementById("style-map").addEventListener("click", () => {
        switchMap("https://regnumsolis.com/planner/images/mvmvmdfs.svg");
      });
    }

    function setupPanZoomLayers() {
      svgRoot = document.getElementById("map-svg-container").querySelector("svg");
      svgRoot.setAttribute("width", "100%");
      svgRoot.setAttribute("height", "100%");
      svgRoot.setAttribute("preserveAspectRatio", "xMidYMid meet");

      panLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      panLayer.id = "pan-layer";
      while (svgRoot.firstChild) { panLayer.appendChild(svgRoot.firstChild); }
      svgRoot.appendChild(panLayer);

      lineLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      lineLayer.id = "line-layer";
      panLayer.appendChild(lineLayer);
      
      markerLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      markerLayer.id = "marker-layer";
      panLayer.appendChild(markerLayer);
      
      textLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      textLayer.id = "text-layer";
      panLayer.appendChild(textLayer);

      // Configure pan-zoom
      panZoomInstance = svgPanZoom(svgRoot, {
        zoomEnabled: true, 
        panEnabled: true, 
        controlIconsEnabled: false, 
        minZoom: 0.5, 
        maxZoom: 5,
        zoomScaleSensitivity: 0.4,
        dblClickZoomEnabled: true,
        preventMouseEventsDefault: true,
        beforeMouseDown: function(e) {
          // Allow click-through for bezier and polygon tools
          if (activeTool === "bezier" || activeTool === "polygon") {
            return false;
          }
          
          // Allow click-through for markers and other interactive elements
          if (e.target.getAttribute("data-marker") === "true" ||
              (e.target.parentNode && e.target.parentNode.getAttribute("data-marker") === "true")) {
            return false;
          }
          
          return true;
        }
      });
      
      // Add event listener for handling map clicks
      svgRoot.addEventListener("click", handleMapClick);
      svgRoot.addEventListener("contextmenu", handleContextMenu);
    }
    
    function handleMapClick(e) {
      if (isUndoRedoAction) return;
      
      const pt = getSVGPoint(e);
      
      if (activeTool === "bezier") {
        bezierControlPoints.push({ x: pt.x, y: pt.y });
        updateBezierPreview();
      } else if (activeTool === "polygon") {
        polygonVertices.push({ x: pt.x, y: pt.y });
        updatePolygonPreview();
      }
    }
    
    function handleContextMenu(e) {
      e.preventDefault();
      
      if (activeTool === "bezier") {
        commitBezier();
      } else if (activeTool === "polygon") {
        commitPolygon();
      }
    }

    function setupToolbox() {
      document.querySelectorAll("#toolbox .tool").forEach((tool) => {
        const type = tool.dataset.type;
        
        // Handle color picker
        if (type === "color") {
          tool.addEventListener("click", () => {
            activeTool = null;
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            openColorPicker();
          });
        }
        // Handle bezier tool
        else if (type === "bezier") {
          tool.addEventListener("click", () => {
            activeTool = "bezier";
            bezierControlPoints = [];
            if (currentBezierPath) { currentBezierPath.remove(); currentBezierPath = null; }
            markerLayer.style.pointerEvents = "none";
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            tool.style.borderColor = "red";
          });
        } 
        // Handle polygon tool
        else if (type === "polygon") {
          tool.addEventListener("click", () => {
            activeTool = "polygon";
            polygonVertices = [];
            if (currentPolygonElement) { currentPolygonElement.remove(); currentPolygonElement = null; }
            markerLayer.style.pointerEvents = "none";
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            tool.style.borderColor = "red";
          });
        }
        // Handle draggable marker tools
        else {
          tool.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("text/plain", type);
            const emptyImg = new Image();
            emptyImg.src = "data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
            e.dataTransfer.setDragImage(emptyImg, 0, 0);
            const dragClone = tool.cloneNode(true);
            dragClone.classList.add("drag-clone");
            dragClone.style.position = "fixed";
            dragClone.style.top = "0px";
            dragClone.style.left = "0px";
            dragClone.style.pointerEvents = "none";
            dragClone.style.zIndex = "1000";
            document.body.appendChild(dragClone);
            tool.dragClone = dragClone;
          });
          tool.addEventListener("drag", (e) => {
            if (!tool.dragClone) return;
            const offsetX = 10;
            const offsetY = 10;
            if (e.clientX > 0) { // Only update if coordinates are valid
              tool.dragClone.style.left = e.clientX + offsetX + "px";
              tool.dragClone.style.top = e.clientY + offsetY + "px";
            }
          });
          tool.addEventListener("dragend", (e) => {
            if (tool.dragClone) {
              tool.dragClone.remove();
              tool.dragClone = null;
            }
          });
        }
      });
    }
    document.addEventListener("dragover", (e) => {
      const activeClone = document.querySelector(".drag-clone");
      if (activeClone) {
        activeClone.style.left = (e.clientX + 10) + "px";
        activeClone.style.top = (e.clientY + 10) + "px";
      }
    });

    function setupDragAndDrop() {
      svgRoot.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      svgRoot.addEventListener("drop", async (e) => {
        if (!isMapReady || activeTool === "bezier" || activeTool === "polygon") return;
        e.preventDefault();
        const type = e.dataTransfer.getData("text/plain");
        const cursorPos = getSVGPoint(e);
        
        // Create a history entry before adding a new marker
        await createHistoryEntry();
await addMarkerToFirestore(type, cursorPos.x, cursorPos.y);
      });
    }

    function setupDrawingTools() {
      // These events are now handled by click and contextmenu handlers
    }

    // Bezier helper: de Casteljau algorithm
    function calculateBezier(points, t) {
      let temp = points.map(p => ({...p}));
      for (let i = temp.length - 1; i > 0; i--) {
        for (let j = 0; j < i; j++) {
          temp[j] = {
            x: temp[j].x + (temp[j+1].x - temp[j].x) * t,
            y: temp[j].y + (temp[j+1].y - temp[j].y) * t
          };
        }
      }
      return temp[0];
    }
    
    // Helper: approximate arc-length midpoint along the bezier curve
    function getBezierArcMidpoint(controlPoints, samples = 100) {
      let pts = [];
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        pts.push(calculateBezier(controlPoints, t));
      }
      let totalLength = 0;
      let cumulative = [0];
      for (let i = 1; i < pts.length; i++) {
        let dx = pts[i].x - pts[i-1].x;
        let dy = pts[i].y - pts[i-1].y;
        let d = Math.sqrt(dx*dx+dy*dy);
        totalLength += d;
        cumulative.push(totalLength);
      }
      let half = totalLength / 2;
      let index = cumulative.findIndex(val => val >= half);
      if (index <= 0) return pts[0];
      let d0 = cumulative[index-1];
      let d1 = cumulative[index];
      let factor = (half - d0) / (d1 - d0);
      let p0 = pts[index-1];
      let p1 = pts[index];
      return { x: p0.x + factor*(p1.x - p0.x), y: p0.y + factor*(p1.y - p0.y) };
    }

    function updateBezierPreview() {
      if (currentBezierPath) { currentBezierPath.remove(); }
      if (bezierControlPoints.length < 2) return;
      currentBezierPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 50;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(bezierControlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      currentBezierPath.setAttribute("d", d);
      currentBezierPath.setAttribute("stroke", "yellow");
      currentBezierPath.setAttribute("stroke-width", "3");
      currentBezierPath.setAttribute("fill", "none");
      lineLayer.appendChild(currentBezierPath);
    }

    function updatePolygonPreview() {
      if (currentPolygonElement) { currentPolygonElement.remove(); }
      if (polygonVertices.length < 2) return;
      currentPolygonElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = polygonVertices.map(p => `${p.x},${p.y}`).join(" ");
      currentPolygonElement.setAttribute("points", pointsStr);
      currentPolygonElement.setAttribute("stroke", selectedColor);
      currentPolygonElement.setAttribute("stroke-width", "2");
      currentPolygonElement.setAttribute("fill", selectedColor);
      currentPolygonElement.setAttribute("fill-opacity", "0.3");
      lineLayer.appendChild(currentPolygonElement);
    }

    async function commitBezier() {
      if (bezierControlPoints.length < 2) return;
      if (currentBezierPath) { currentBezierPath.remove(); currentBezierPath = null; }
      
      // Create a history entry before adding a new bezier
      await createHistoryEntry();
      
      // Use the globally selectedColor
      const bezierColor = selectedColor;
      
      // Create a group to hold the bezier path and its arrows
      const bezierGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");

      // Create the bezier path element
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 100;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(bezierControlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      pathElem.setAttribute("d", d);
      pathElem.setAttribute("stroke", bezierColor);
      pathElem.setAttribute("stroke-width", "3");
      pathElem.setAttribute("fill", "none");
      bezierGroup.appendChild(pathElem);

      // Arrow at the end (using t=0.98 to t=1.0)
      let pt1 = calculateBezier(bezierControlPoints, 0.98);
      let pt2 = calculateBezier(bezierControlPoints, 1.0);
      let angleEnd = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x) * (180/Math.PI);
      const arrowEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowEnd.setAttribute("points", "0,-8 16,0 0,8");
      arrowEnd.setAttribute("fill", bezierColor);
      arrowEnd.setAttribute("transform", `translate(${pt2.x},${pt2.y}) rotate(${angleEnd})`);
      bezierGroup.appendChild(arrowEnd);

      // Calculate arc-length midpoint and arrow in the middle
      let midPt = getBezierArcMidpoint(bezierControlPoints, 100);
      let angleMid = Math.atan2(pt2.y - midPt.y, pt2.x - midPt.x) * (180/Math.PI);
      const arrowMid = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowMid.setAttribute("points", "0,-8 16,0 0,8");
      arrowMid.setAttribute("fill", bezierColor);
      arrowMid.setAttribute("transform", `translate(${midPt.x},${midPt.y}) rotate(${angleMid})`);
      bezierGroup.appendChild(arrowMid);

      lineLayer.appendChild(bezierGroup);

      try {
        const docRef = await addDoc(collection(db, "bezierCurves"), {
          controlPoints: bezierControlPoints,
          color: bezierColor,
          timestamp: serverTimestamp(),
          owner: auth.currentUser.uid
        });
        recordAuditLog("add_bezier", { bezierId: docRef.id });
        bezierGroup.dataset.id = docRef.id;
        bezierGroup.setAttribute("data-bezier", "true");
      } catch (error) {
        console.error("Error adding bezier curve:", error);
      }
      
      // Add click handler for deletion
      bezierGroup.addEventListener("click", (e) => {
        e.stopPropagation();
        
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        customConfirm("Delete this bezier curve?").then(async confirmed => {
          if (confirmed) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            deleteDoc(doc(db, "bezierCurves", bezierGroup.dataset.id))
              .then(() => {
                recordAuditLog("delete_bezier", { bezierId: bezierGroup.dataset.id });
                bezierGroup.remove();
              })
              .catch(error => {
                console.error("Error deleting bezier curve:", error);
              })
              .finally(() => {
                isDeleteInProgress = false;
              });
          } else {
            isDeleteInProgress = false;
          }
        });
      });
      
      activeTool = null;
      bezierControlPoints = [];
      markerLayer.style.pointerEvents = "auto";
      document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
    }

    async function commitPolygon() {
      if (polygonVertices.length < 3) return;
      if (currentPolygonElement) { currentPolygonElement.remove(); currentPolygonElement = null; }
      
      // Create a history entry before adding a new polygon
      await createHistoryEntry();
      
      const polygonElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = polygonVertices.map(p => `${p.x},${p.y}`).join(" ");
      polygonElem.setAttribute("points", pointsStr);
      polygonElem.setAttribute("stroke", selectedColor);
      polygonElem.setAttribute("stroke-width", "2");
      polygonElem.setAttribute("fill", selectedColor);
      polygonElem.setAttribute("fill-opacity", "0.3");
      polygonElem.setAttribute("data-polygon", "true");
      lineLayer.appendChild(polygonElem);
      
      try {
        const docRef = await addDoc(collection(db, "polygons"), {
          vertices: polygonVertices,
          color: selectedColor,
          timestamp: serverTimestamp(),
          owner: auth.currentUser.uid
        });
        recordAuditLog("add_polygon", { polygonId: docRef.id });
        polygonElem.dataset.id = docRef.id;
      } catch (error) {
        console.error("Error adding polygon:", error);
      }
      
      // Add click handler for deletion
      polygonElem.addEventListener("click", (e) => {
        e.stopPropagation();
        
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        customConfirm("Delete this polygon?").then(async confirmed => {
          if (confirmed) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            deleteDoc(doc(db, "polygons", polygonElem.dataset.id))
              .then(() => {
                recordAuditLog("delete_polygon", { polygonId: polygonElem.dataset.id });
                polygonElem.remove();
              })
              .catch(error => {
                console.error("Error deleting polygon:", error);
              })
              .finally(() => {
                isDeleteInProgress = false;
              });
          } else {
            isDeleteInProgress = false;
          }
        });
      });
      
      activeTool = null;
      polygonVertices = [];
      markerLayer.style.pointerEvents = "auto";
      document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
    }

    async function addMarkerToFirestore(type, x, y) {
      const user = auth.currentUser;
      if (!user) { console.error("User not authenticated"); return; }
      
      let markerData = { 
        type, x, y, 
        timestamp: serverTimestamp(), 
        owner: user.uid 
      };
      
      if (["homestead", "keep", "torch", "cave", "sword", "spear", "bow", "beacon", "camp", "catapult", "ram"].includes(type)) {
        markerData.text = await customPrompt("Enter marker text:", "") || "";
        markerData.color = selectedColor;
      }
      
      try {
        const docRef = await addDoc(collection(db, "markers"), markerData);
        recordAuditLog("add", { markerId: docRef.id, markerType: type });
      } catch (error) {
        console.error("Error adding marker:", error);
      }
    }

    function listenForBezierCurves() {
      const bezierQuery = query(collection(db, "bezierCurves"), orderBy("timestamp"));
      onSnapshot(bezierQuery, (snapshot) => {
        // Clear all bezier elements without an ID
        lineLayer.querySelectorAll("g:not([data-id])").forEach(elem => elem.remove());

        // Clear all bezier elements with an ID that's not in the current snapshot
        const currentIds = new Set();
        snapshot.forEach(docSnap => { currentIds.add(docSnap.id); });

        lineLayer.querySelectorAll("g[data-bezier='true'][data-id]").forEach(elem => {
          if (!currentIds.has(elem.dataset.id)) {
            elem.remove();
          }
        });

        // Create or update bezier elements from snapshot
        snapshot.forEach(docSnap => {
          const id = docSnap.id;
          const existingElem = lineLayer.querySelector(`g[data-id="${id}"]`);
          if (!existingElem) {
            createBezierElement(id, docSnap.data());
          }
        });
      });
    }

    function createBezierElement(id, data) {
      const bezierGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      bezierGroup.dataset.id = id;
      bezierGroup.setAttribute("data-bezier", "true");
      
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 100;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(data.controlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      pathElem.setAttribute("d", d);
      pathElem.setAttribute("stroke", data.color);
      pathElem.setAttribute("stroke-width", "3");
      pathElem.setAttribute("fill", "none");
      bezierGroup.appendChild(pathElem);

      let pt1 = calculateBezier(data.controlPoints, 0.98);
      let pt2 = calculateBezier(data.controlPoints, 1.0);
      let angleEnd = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x) * (180/Math.PI);
      const arrowEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowEnd.setAttribute("points", "0,-8 16,0 0,8");
      arrowEnd.setAttribute("fill", data.color);
      arrowEnd.setAttribute("transform", `translate(${pt2.x},${pt2.y}) rotate(${angleEnd})`);
      bezierGroup.appendChild(arrowEnd);

      let midPt = getBezierArcMidpoint(data.controlPoints, 100);
      let angleMid = Math.atan2(pt2.y - midPt.y, pt2.x - midPt.x) * (180/Math.PI);
      const arrowMid = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowMid.setAttribute("points", "0,-8 16,0 0,8");
      arrowMid.setAttribute("fill", data.color);
      arrowMid.setAttribute("transform", `translate(${midPt.x},${midPt.y}) rotate(${angleMid})`);
      bezierGroup.appendChild(arrowMid);
      
      // Add click handler for deletion
      bezierGroup.addEventListener("click", (e) => {
        e.stopPropagation();
        
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        customConfirm("Delete this bezier curve?").then(async confirmed => {
          if (confirmed) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            deleteDoc(doc(db, "bezierCurves", id))
              .then(() => {
                recordAuditLog("delete_bezier", { bezierId: id });
                bezierGroup.remove();
              })
              .catch(error => {
                console.error("Error deleting bezier curve:", error);
              })
              .finally(() => {
                isDeleteInProgress = false;
              });
          } else {
            isDeleteInProgress = false;
          }
        });
      });

      lineLayer.appendChild(bezierGroup);
    }

    function listenForPolygons() {
      const polyQuery = query(collection(db, "polygons"), orderBy("timestamp"));
      onSnapshot(polyQuery, (snapshot) => {
        // Clear all polygon elements without an ID
        lineLayer.querySelectorAll("polygon:not([data-id])").forEach(elem => elem.remove());

        // Clear all polygon elements with an ID that's not in the current snapshot
        const currentIds = new Set();
        snapshot.forEach(docSnap => { currentIds.add(docSnap.id); });

        lineLayer.querySelectorAll("polygon[data-polygon='true'][data-id]").forEach(elem => {
          if (!currentIds.has(elem.dataset.id)) {
            elem.remove();
          }
        });

        // Create or update polygon elements from snapshot
        snapshot.forEach(docSnap => {
          const id = docSnap.id;
          const existingElem = lineLayer.querySelector(`polygon[data-id="${id}"]`);
          if (!existingElem) {
            createPolygonElement(id, docSnap.data());
          }
        });
      });
    }

    function createPolygonElement(id, data) {
      const polygonElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = data.vertices.map(p => `${p.x},${p.y}`).join(" ");
      polygonElem.setAttribute("points", pointsStr);
      polygonElem.setAttribute("stroke", data.color);
      polygonElem.setAttribute("stroke-width", "2");
      polygonElem.setAttribute("fill", data.color);
      polygonElem.setAttribute("fill-opacity", "0.3");
      polygonElem.dataset.id = id;
      polygonElem.setAttribute("data-polygon", "true");
      
      // Add click handler for deletion
      polygonElem.addEventListener("click", (e) => {
        e.stopPropagation();
        
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        customConfirm("Delete this polygon?").then(async confirmed => {
          if (confirmed) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            deleteDoc(doc(db, "polygons", id))
              .then(() => {
                recordAuditLog("delete_polygon", { polygonId: id });
                polygonElem.remove();
              })
              .catch(error => {
                console.error("Error deleting polygon:", error);
              })
              .finally(() => {
                isDeleteInProgress = false;
              });
          } else {
            isDeleteInProgress = false;
          }
        });
      });
      
      lineLayer.appendChild(polygonElem);
    }

    function listenForMarkers() {
      let snapshotReceived = false;
      const markersQuery = query(collection(db, "markers"), orderBy("timestamp"));
      const unsubscribe = onSnapshot(markersQuery, (snapshot) => {
        snapshotReceived = true;
        while (markerLayer.firstChild) { markerLayer.removeChild(markerLayer.firstChild); }
        snapshot.forEach((docSnap) => { createMarkerElement(docSnap.id, docSnap.data()); });
        updateMarkerVisibility();
      }, (error) => {
        console.error("Firestore connection error:", error);
        displayErrorOverlay("Firestore connection failed.");
      });
      setTimeout(() => {
        if (!snapshotReceived) { console.error("No Firestore snapshot received within timeout."); displayErrorOverlay("Firestore connection failed."); unsubscribe(); }
      }, 5000);
    }

    function listenForLines() {
      const linesQuery = query(collection(db, "lines"), orderBy("timestamp"));
      onSnapshot(linesQuery, (snapshot) => {
        lineLayer.querySelectorAll(".line-group").forEach(elem => elem.remove());
        snapshot.forEach((docSnap) => { createLineElement(docSnap.id, docSnap.data()); });
        updateLineVisibility();
      });
    }

    function createMarkerElement(id, data) {
      let markerEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
      markerEl.setAttribute("data-marker", "true");
      markerEl.dataset.type = data.type;
      markerEl.dataset.id = id;
      
      let imgSrc, imgWidth, imgHeight, imgXOffset, imgYOffset, fontSize;
      if (data.type === "homestead") {
        imgSrc = "https://regnumsolis.com/planner/images/marker.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -(imgWidth / 2); imgYOffset = -20 * 1.7; fontSize = 16 * 1.7;
      } else if (data.type === "keep") {
        imgSrc = "https://regnumsolis.com/planner/images/citadel.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "torch") {
        imgSrc = "https://regnumsolis.com/planner/images/torch.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "cave") {
        imgSrc = "https://regnumsolis.com/planner/images/cave.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "sword") {
        imgSrc = "https://regnumsolis.com/planner/images/sword.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "spear") {
        imgSrc = "https://regnumsolis.com/planner/images/spear.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "bow") {
        imgSrc = "https://regnumsolis.com/planner/images/bow.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "beacon") {
        imgSrc = "https://regnumsolis.com/planner/images/beacon.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "camp") {
        imgSrc = "https://regnumsolis.com/planner/images/camp.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "catapult") {
        imgSrc = "https://regnumsolis.com/planner/images/catapult.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "ram") {
        imgSrc = "https://regnumsolis.com/planner/images/ram.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      }
      let textXOffset = imgXOffset + imgWidth;
      const imgEl = document.createElementNS("http://www.w3.org/2000/svg", "image");
      imgEl.setAttributeNS("http://www.w3.org/1999/xlink", "href", imgSrc);
      imgEl.setAttribute("width", imgWidth);
      imgEl.setAttribute("height", imgHeight);
      imgEl.setAttribute("x", data.x + imgXOffset);
      imgEl.setAttribute("y", data.y + imgYOffset);
      markerEl.appendChild(imgEl);
      const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.textContent = data.text;
      textEl.setAttribute("fill", data.color || "#dfc588");
      textEl.setAttribute("font-size", fontSize);
      textEl.setAttribute("x", data.x + textXOffset);
      textEl.setAttribute("y", data.y);
      textEl.setAttribute("text-anchor", "start");
      textEl.setAttribute("dominant-baseline", "middle");
      textEl.style.fontFamily = "'Bebas Neue', sans-serif";
      markerEl.appendChild(textEl);
      requestAnimationFrame(() => {
        const bbox = textEl.getBBox();
        const textLength = textEl.getComputedTextLength();
        const rectEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rectEl.setAttribute("x", bbox.x);
        rectEl.setAttribute("y", bbox.y);
        rectEl.setAttribute("width", textLength);
        rectEl.setAttribute("height", bbox.height);
        rectEl.setAttribute("fill", "#1e1e1e");
        rectEl.setAttribute("opacity", "0.63");
        markerEl.insertBefore(rectEl, textEl);
      });
      markerEl.classList.add("marker");
      
      // Add click handler for deletion
      markerEl.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        try {
          if (await customConfirm("Delete this marker?")) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            await deleteDoc(doc(db, "markers", id));
            recordAuditLog("delete", { markerId: id, markerType: data.type });
            markerEl.remove();
          }
        } catch (error) {
          console.error("Error deleting marker:", error);
        } finally {
          isDeleteInProgress = false;
        }
      });
      
      markerLayer.appendChild(markerEl);
    }

    function createLineElement(id, data) {
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("line-group");
      group.dataset.id = id;
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", data.x1);
      line.setAttribute("y1", data.y1);
      line.setAttribute("x2", data.x2);
      line.setAttribute("y2", data.y2);
      line.setAttribute("stroke", data.color);
      line.setAttribute("stroke-width", "3.2");
      
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrow.setAttribute("points", "0,-8 16,0 0,8");
      arrow.setAttribute("fill", data.color);
      arrow.setAttribute("transform", `translate(${data.midX},${data.midY}) rotate(${data.angle})`);
      
      group.appendChild(line);
      group.appendChild(arrow);
      
      // Add click handler for deletion
      group.addEventListener("click", async (e) => {
        e.stopPropagation();
        
        if (activeTool === "bezier" || activeTool === "polygon") return;
        
        // Prevent double deletion prompts
        if (isDeleteInProgress) return;
        isDeleteInProgress = true;
        
        try {
          if (await customConfirm("Delete this line?")) {
            // Create a history entry before deleting
            await createHistoryEntry();
            
            await deleteDoc(doc(db, "lines", id));
            recordAuditLog("delete_line", { lineId: id });
            group.remove();
          }
        } catch (error) {
          console.error("Error deleting line:", error);
        } finally {
          isDeleteInProgress = false;
        }
      });
      
      lineLayer.appendChild(group);
    }

    function recordAuditLog(action, details) {
      const user = auth.currentUser;
      if (!user) return;
      const logData = { action, details, user: user.email, timestamp: serverTimestamp() };
      addDoc(collection(db, "auditLogs"), logData)
        .catch(error => console.error("Error writing audit log:", error));
    }

    function listenForAuditLogs() {
      const auditContainer = document.getElementById("audit-log-container");
      const auditQuery = query(collection(db, "auditLogs"), orderBy("timestamp", "asc"));
      onSnapshot(auditQuery, (snapshot) => {
        const logs = [];
        snapshot.forEach(docSnap => {
          logs.push(docSnap.data());
        });
        const grouped = [];
        logs.forEach(log => {
          if (grouped.length === 0) {
            grouped.push({ log: log, count: 1 });
          } else {
            const lastGroup = grouped[grouped.length - 1];
            const sameAction = lastGroup.log.action === log.action;
            let sameMarkerType = true;
            if (log.action === "add" || log.action === "delete") {
              sameMarkerType = (lastGroup.log.details.markerType === log.details.markerType);
            }
            if (sameAction && sameMarkerType) {
              lastGroup.count++;
            } else {
              grouped.push({ log: log, count: 1 });
            }
          }
        });
        auditContainer.innerHTML = "";
        grouped.forEach(group => {
          const log = group.log;
          const dateStr = new Date(log.timestamp ? log.timestamp.seconds * 1000 : Date.now()).toLocaleString();
          let detailsText = "";
          if (log.details && log.details.markerType) {
            detailsText = ` (${log.details.markerType})`;
          }
          const groupCount = group.count > 1 ? ` <span class="log-group">(x${group.count})</span>` : "";
          const entry = document.createElement("div");
          entry.innerHTML = `[${dateStr}] <span class="log-user">${log.user}</span> <span class="log-action">${log.action}${detailsText}</span>${groupCount}`;
          auditContainer.appendChild(entry);
        });
      });
    }

    function getSVGPoint(e) {
      const pt = svgRoot.createSVGPoint();
      pt.x = e.clientX; pt.y = e.clientY;
      return pt.matrixTransform(panLayer.getScreenCTM().inverse());
    }

    function displayErrorOverlay(message) {
      const overlay = document.getElementById("error-overlay");
      overlay.textContent = message;
      overlay.style.display = "flex";
      console.warn("Error overlay activated:", message);
    }
  </script>
  <script>
    function customPrompt(message, defaultValue) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("custom-prompt-overlay");
        const promptMessage = document.getElementById("custom-prompt-message");
        const promptInput = document.getElementById("custom-prompt-input");
        const okButton = document.getElementById("custom-prompt-ok");
        const cancelButton = document.getElementById("custom-prompt-cancel");
        promptMessage.textContent = message;
        promptInput.value = defaultValue || "";
        promptInput.style.display = "block";
        overlay.style.display = "flex";
        promptInput.focus();
        function cleanup() {
          overlay.style.display = "none";
          okButton.removeEventListener("click", onOk);
          cancelButton.removeEventListener("click", onCancel);
          promptInput.removeEventListener("keydown", onKeyDown);
        }
        function onOk() { resolve(promptInput.value); cleanup(); }
        function onCancel() { resolve(null); cleanup(); }
        function onKeyDown(e) { if (e.key === "Enter") { onOk(); } }
        okButton.addEventListener("click", onOk);
        cancelButton.addEventListener("click", onCancel);
        promptInput.addEventListener("keydown", onKeyDown);
      });
    }
  </script>
  <script>
    function customConfirm(message) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("custom-prompt-overlay");
        const promptMessage = document.getElementById("custom-prompt-message");
        const promptInput = document.getElementById("custom-prompt-input");
        const okButton = document.getElementById("custom-prompt-ok");
        const cancelButton = document.getElementById("custom-prompt-cancel");

        promptMessage.textContent = message;
        promptInput.style.display = "none";
        overlay.style.display = "flex";

        function cleanup() {
          overlay.style.display = "none";
          promptInput.style.display = "block";
          okButton.removeEventListener("click", onOk);
          cancelButton.removeEventListener("click", onCancel);
          // Reset the isDeleteInProgress flag when the dialog is closed
          isDeleteInProgress = false;
        }

        function onOk() { 
          cleanup();
          resolve(true); 
        }

        function onCancel() { 
          cleanup();
          resolve(false); 
        }

        okButton.addEventListener("click", onOk);
        cancelButton.addEventListener("click", onCancel);
      });
    }
  </script>
  <script>
    // WebGL background shader setup restored
    const canvas = document.getElementById('waveCanvas');
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");
    if (!gl) { alert("WebGL is not supported in your browser."); }

    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;
    const fragmentShaderSource = `
      precision mediump float;
      uniform float u_time;
      uniform vec2 u_resolution;
      varying vec2 v_uv;
      float wave(vec2 st, float angle, float frequency, float amplitude, float speed) {
        vec2 dir = vec2(cos(angle), sin(angle));
        float phaseOffset = angle * 7.0;
        return sin(dot(st, dir) * frequency + u_time * speed + phaseOffset) * amplitude;
      }
      float waveHeight(vec2 st) {
        float h = 0.0;
        h += wave(st, 0.0, 30.1, 0.0020, 0.81);
        h += wave(st, 0.7, 40.3, 0.0017, 0.63);
        h += wave(st, 1.4, 55.7, 0.0010, 1.04);
        h += wave(st, 2.1, 65.2, 0.0012, 0.91);
        h += wave(st, 2.8, 50.5, 0.0015, 1.12);
        h += wave(st, 3.3, 60.9, 0.0013, 0.87);
        h += wave(st, 4.0, 45.6, 0.0014, 1.05);
        h += wave(st, 4.7, 70.8, 0.0011, 0.99);
        return h;
      }
      vec3 computeNormal(vec2 st, float h) {
        float eps = 0.001;
        float hx = waveHeight(st + vec2(eps, 0.0));
        float hy = waveHeight(st + vec2(0.0, eps));
        float dFdx = (hx - h) / eps;
        float dFdy = (hy - h) / eps;
        return normalize(vec3(-dFdx, -dFdy, 1.0));
      }
      void main(){
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.y *= u_resolution.y / u_resolution.x;
        float h = waveHeight(st);
        vec3 normal = computeNormal(st, h);
        vec3 deepWater = vec3(0.0, 0.15, 0.35);
        vec3 shallowWater = vec3(0.0, 0.45, 0.75);
        vec3 baseColor = mix(deepWater, shallowWater, st.y + h * 0.5);
        vec3 sunDir = normalize(vec3(0.3, 0.8, 1.0));
        float diffuse = max(dot(normal, sunDir), 0.0);
        vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));
        vec3 halfDir = normalize(sunDir + viewDir);
        float spec = pow(max(dot(normal, halfDir), 0.0), 50.0);
        float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0) * 0.6;
        vec3 color = baseColor * (0.4 + 0.6 * diffuse) + vec3(1.0, 0.95, 0.8) * spec;
        color = mix(color, vec3(1.0), fresnel);
        color *= 0.1;
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        console.error("Shader compile error: ", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
        console.error("Program link error: ", gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);
    gl.useProgram(program);

    const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
      -1, -1,
      1, -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
    const timeUniformLocation = gl.getUniformLocation(program, "u_time");

    function render(time) {
      time *= 0.001;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(timeUniformLocation, time);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
    
    // Add event listener to handle window resize properly
    window.addEventListener('resize', function() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    });
  </script>
</body>
</html>
